using MediatR;
using MassTransit;
using WorkoutService.Features.Workouts.CreateWorkout.ViewModels;
using WorkoutService.Contracts;
using WorkoutService.Domain.Interfaces; // ✅ Required for IUnitOfWork

namespace WorkoutService.Features.Workouts.CreateWorkout
{
    public class CreateWorkoutHandler : IRequestHandler<CreateWorkoutCommand, WorkoutVm>
    {
        private readonly IPublishEndpoint _publishEndpoint;
        private readonly IUnitOfWork _unitOfWork; // ✅ Re-injected to handle Outbox persistence

        public CreateWorkoutHandler(
            IPublishEndpoint publishEndpoint,
            IUnitOfWork unitOfWork)
        {
            _publishEndpoint = publishEndpoint;
            _unitOfWork = unitOfWork;
        }

        public async Task<WorkoutVm> Handle(CreateWorkoutCommand request, CancellationToken cancellationToken)
        {
            // 1. Publish Event to Outbox
            // Since we enabled the "Transactional Outbox" in Program.cs, this Publish call 
            // does NOT send the message to RabbitMQ immediately.
            // Instead, it adds the message to the DbContext (in the 'OutboxMessage' table).
            await _publishEndpoint.Publish<IWorkoutCreated>(new
            {
                // We send ID as 0 because the actual ID will be generated by the Consumer later.
                WorkoutId = 0,
                Name = request.Dto.Name,
                Description = request.Dto.Description,
                CaloriesBurn = request.Dto.CaloriesBurn,
                Category = request.Dto.Category,
                Difficulty = request.Dto.Difficulty,
                DurationInMinutes = request.Dto.DurationInMinutes,
                IsPremium = request.Dto.IsPremium,
                Rating = 0.0,
                CreatedAt = DateTime.UtcNow,

                // Crucial for linking the workout to a plan in the Consumer
                WorkoutPlanId = request.Dto.workoutPlanId
            }, cancellationToken);

            // ✅ 2. Persist Message to Database (The Fix)
            // Even though we are not saving the 'Workout' entity here, we MUST call SaveChanges.
            // This writes the published message from memory into the SQL 'OutboxMessage' table.
            // Without this, the message remains pending in memory and the request hangs.
            await _unitOfWork.SaveChangesAsync(cancellationToken);

            // 3. Return Immediate Response (Fire-and-Forget)
            // The actual workout creation happens asynchronously by the Consumer.
            return new WorkoutVm(0, request.Dto.Name, request.Dto.Description);
        }
    }
}